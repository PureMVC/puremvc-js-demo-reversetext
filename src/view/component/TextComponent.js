/**
 * @class demo.view.TextComponent
 * @implements EventListener
 * 
 * TextComponent is implemented without any abstract concept of a UiComponent
 * or Sprite, and uses standard HTML5 methods to manipulate the DOM. It
 * does however implement the {@link #handleEvent W3C EventListener interface}
 * which means it can be passed directly to HTMLElement#addEventListener, rather
 * than providing a Function, leading to tidier code and no need for Function#bind 
 * to preserve the execution scope of its methods.
 */
puremvc.define
(
	// CLASS INFO
	{
		name: 'demo.view.component.TextComponent',
	
		/** @constructor */
		constructor: function ()
		{
			// use HTML5 querySelector for DOM retrieval
			this.textForm			= document.querySelector('#textForm');
			this.textInput			= this.textForm.querySelector('#inputText');
			this.textOutput			= this.textForm.querySelector('#outputText');
			this.textOutputLabel 	= this.textForm.querySelector('#outputTextLabel');
			this.checkbox			= this.textForm.querySelector('input[type=checkbox]');
			this.reverseButton 		= this.textForm.querySelector('button[type=submit]');
			
			// listen to checkbox state changes, handled by #handleEvent
			this.checkbox.addEventListener( 'change', this );
			
			// listen to reverse button clicks, handled by #handleEvent
			this.reverseButton.addEventListener( 'click', this );
			
			// listen for input keystrokes, handled by #handleEvent
			this.textInput.addEventListener( 'keyup', this );	
		}
	},

	// INSTANCE MEMBERS 
	{
		/**
		 * @private
		 * @type {HTMLInputElement}
		 */
		textInput: null,
		
		/**
		 * @private
		 * @type {HTMLInputElement}
		 */
		textOutput: null,

		/**
		 * @private
		 * @type {HTMLLabelElement}
		 */
		textOutputLabel: null,
		
		
		/**
		 * @private
		 * @type {HTMLButtonElement}
		 */
		reverseButton: null,
				
		/**
		 * Set the palindrome indicator
		 * @param {string}
		 * @return {void}
		 */
		setIsPalindrome: function (value)
		{
			if (value) 
				this.textOutputLabel.innerHTML = "Palindrome Detected";
			else
				this.textOutputLabel.innerHTML = "Output Text";
		},
		
		/**
		 * Set the ouput fields text value
		 * @param {string}
		 * @return {void}
		 */
		setOutputText: function (value)
		{
			this.setIsPalindrome( false );
			this.textOutput.value = value;
		},
		
		/**
		 * Get the input fields text value
		 * @return {string}
		 */
		getInputText: function ()
		{
			return this.textInput.value;
		},
		
		/**
		 * Add EventListeners to TextComponent. TextComponent will
		 * dispatch only TextComponent#TEXT_CHANGED events, but
		 * you can still listen to other events generated by its
		 * DOM elements as they propagate through #textForm
		 * 
		 * @param {string} type
		 * @param {Function|Object} listener
		 * @param {boolean} bubbles
		 * @return {void}
		 */
		addEventListener: function ( type, listener, useCapture )
		{
			// delegate to #textForm
			this.textForm.addEventListener( type, listener, useCapture );
		},
		
		/**
		 * An implementation of the 
		 * {@link http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Registration-interfaces W3C EventListener interface}. 
		 * This allows the component to be added to its child components as
		 * an event listener, without explicitly specifying a Function callback
		 * - the #handleEvent method will be invoked by EventDispatchers automatically.
		 * 
		 * If the component was more complex, actions would be broken
		 * out and encapsulated as individual methods.
		 * 
		 * @param {Event} domEvent
		 * @return {void}
		 * @see 
		 */
		handleEvent: function (domEvent)
		{
			switch(domEvent.type)
			{
				/*
				 * The TextComponent's reverse as I type option is
				 * enabled and a keypress has been detected- j
				 * ust fire a text changed event
				 */
				case 'keyup':
					if (this.checkbox.checked) this.dispatchTextChangedEvent();
					break;
				
				/*
				 * The TextComponent's reverse button has been clicked.
				 * Prevent the form from submitting, and fire a
				 * text changed event
				 */								
				case 'click':
					domEvent.preventDefault();
					this.dispatchTextChangedEvent();
					break;
				
			}
		},

		/**
		 * @private
		 * Read the inputText fields value and dispatch a text changed event
		 * via TextComponents #textForm element.
		 * @return {void}
		 */
		dispatchTextChangedEvent: function ()
		{
			// use W3C compliant synthetic events dispatch api (SORRY, NO IE SUPPORT)
			var textChangedEvent= document.createEvent( "Events" );
			textChangedEvent.initEvent(this.constructor.TEXT_CHANGED, false, false);
			textChangedEvent.text= this.getInputText();
			this.textForm.dispatchEvent( textChangedEvent );
		}
	},
	
	// STATIC MEMBERS	
	{
		/**
		 * @static
		 * @type {string}
		 */
		TEXT_CHANGED: 'textChanged'
	}
);
